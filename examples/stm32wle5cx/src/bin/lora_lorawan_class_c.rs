//! This example runs on a RAK3272s board, which has a builtin Semtech Sx1262 radio.
//! It demonstrates join bias for US868 devices and Class C functionality.
#![no_std]
#![no_main]

#[path = "../iv.rs"]
mod iv;

use defmt::info;

use embassy_executor::Spawner;
use embassy_futures::select::{Either, select};
use embassy_stm32::exti::ExtiInput;
use embassy_stm32::gpio::{Level, Output, Speed};
use embassy_stm32::mode::Async;
use embassy_stm32::rng::{self, Rng};
use embassy_stm32::spi::{Spi, mode::Master};
use embassy_stm32::{bind_interrupts, peripherals};
use embassy_sync::{
    blocking_mutex::raw::ThreadModeRawMutex,
    channel::{Channel, Receiver, Sender},
};
use embassy_time::Delay;

use lora_phy::LoRa;
use lora_phy::lorawan_radio::LorawanRadio;
use lora_phy::sx126x::{self, Stm32wl, Sx126x};
use lorawan_device::async_device::{Device, EmbassyTimer, JoinMode, JoinResponse, SendResponse};
use lorawan_device::region::{Configuration, Region};
use lorawan_device::{AppEui, AppKey, DevEui};
use {defmt_rtt as _, panic_probe as _};

use self::iv::{InterruptHandler, Stm32wlInterfaceVariant, SubghzSpiDevice};

const MAX_TX_POWER: u8 = 21;
// During uplinks, it possible to receive a class A downlink and many Class C downlinks.
// Increasing the stacks buffer to at least 3 is a good start.
const DOWNLINK_BUFFER: usize = 3;

// Load optional override values for EUIs and APPKEY generated by build.rs from
// environment values
include!(concat!(env!("OUT_DIR"), "/lorawan_keys.rs"));

// Fallback values
const DEFAULT_DEVEUI: [u8; 8] = [0, 0, 0, 0, 0, 0, 0, 0];
const DEFAULT_APPEUI: [u8; 8] = [0, 0, 0, 0, 0, 0, 0, 0];
const DEFAULT_APPKEY: [u8; 16] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];

bind_interrupts!(struct Irqs{
    SUBGHZ_RADIO => InterruptHandler;
    RNG => rng::InterruptHandler<peripherals::RNG>;
});

static CHANNEL: Channel<ThreadModeRawMutex, ButtonState, 3> = Channel::new();

#[embassy_executor::main]
async fn main(spawner: Spawner) {
    info!("Setting up...");
    let mut config = embassy_stm32::Config::default();
    {
        use embassy_stm32::rcc::*;
        config.rcc.msi = Some(embassy_stm32::rcc::MSIRange::RANGE48M);
        config.rcc.sys = Sysclk::MSI;
        config.rcc.mux.rngsel = mux::Rngsel::MSI;
        config.enable_debug_during_sleep = true;
    }
    let p = embassy_stm32::init(config);

    info!("config done...");
    let tx_pin = Output::new(p.PC13, Level::Low, Speed::VeryHigh);
    let rx_pin = Output::new(p.PB8, Level::Low, Speed::VeryHigh);

    let spi = Spi::new_subghz(p.SUBGHZSPI, p.DMA1_CH1, p.DMA1_CH2);
    let spi = SubghzSpiDevice(spi);
    let use_high_power_pa = true;
    let config = sx126x::Config {
        chip: Stm32wl { use_high_power_pa },
        tcxo_ctrl: None,
        use_dcdc: true,
        rx_boost: false,
    };
    let iv = Stm32wlInterfaceVariant::new(Irqs, use_high_power_pa, Some(rx_pin), Some(tx_pin), None).unwrap();
    let lora = LoRa::new(Sx126x::new(spi, iv, config), true, Delay).await.unwrap();
    let _lora_task = spawner.spawn(lora_task(lora, Rng::new(p.RNG, Irqs), CHANNEL.receiver()));

    // let _button_task = spawner.spawn(button_task(button, CHANNEL.sender()));
}

type Stm32wlLoRa<'d, CM> =
    LoRa<Sx126x<iv::SubghzSpiDevice<Spi<'d, Async, CM>>, Stm32wlInterfaceVariant<Output<'d>>, Stm32wl>, Delay>;

#[embassy_executor::task]
async fn lora_task(
    lora: Stm32wlLoRa<'static, Master>,
    rng: Rng<'static, peripherals::RNG>,
    rx: Receiver<'static, ThreadModeRawMutex, ButtonState, 3>,
) {
    let radio: LorawanRadio<_, _, MAX_TX_POWER> = lora.into();
    // TODO: Set appropriage region
    let conf = Configuration::new(Region::EU868);
    // Setting join bias causes the device to attempt the first join on subband 2.
    // If it fails, it will proceed with the other subbands sequentially.
    // us915.set_join_bias(Subband::_2);
    let mut device: Device<_, _, _, 256, DOWNLINK_BUFFER> = Device::new(conf, radio, EmbassyTimer::new(), rng);
    device.enable_class_c();

    // TODO: Adjust the EUI and Keys according to your network credentials
    let join_mode = JoinMode::OTAA {
        deveui: DevEui::from(DEVEUI.unwrap_or(DEFAULT_DEVEUI)),
        appeui: AppEui::from(APPEUI.unwrap_or(DEFAULT_APPEUI)),
        appkey: AppKey::from(APPKEY.unwrap_or(DEFAULT_APPKEY)),
    };

    info!("Joining LoRaWAN network");
    loop {
        let join_result = device.join(&join_mode).await;
        if let Ok(JoinResponse::JoinSuccess) = join_result {
            info!("LoRaWAN network joined");
            break;
        }
        info!("Join failed: {:?}. Retrying...", join_result);
    }

    // After joining Class C, the LoRaWAN specification indicates that it is important to send a
    // confirmed uplink immediately after joining until confirmed such that Class C downlinks are
    // enabled.
    loop {
        info!("Sending uplink...");
        let result = device.send(&[0x01, 0x02, 0x03, 0x04], 1, true).await;
        if let Ok(SendResponse::DownlinkReceived(_)) = result {
            // After an uplink with Class C enabled, it is important to check for multiple downlinks.
            // It is theoretically possible to receive a Class A downlink and any number of Class C
            // downlinks during the Class C windows.
            while let Some(downlink) = device.take_downlink() {
                info!("Received {:?}", downlink);
            }
            break;
        } else {
            info!("Uplink failed: {:?}. Retrying...", result);
        }
    }

    loop {
        let either = select(rx.receive(), device.rxc_listen()).await;
        match either {
            Either::First(button_state) => {
                info!("Button state: {:?}", button_state);
                let resp = device.send(&[0x03], 1, true).await;
                info!("Sent uplink: {:?}", resp);
                // After an uplink with Class C enabled, it is important to check for multiple downlinks.
                // It is theoretically possible to receive a Class A downlink and any number of Class C
                // downlinks during the Class C windows.
                while let Some(downlink) = device.take_downlink() {
                    info!("Received {:?}", downlink);
                }
            }
            Either::Second(downlink) => {
                info!("Received {:?}", downlink);
                while let Some(downlink) = device.take_downlink() {
                    info!("Received {:?}", downlink);
                }
            }
        }
    }
}

#[derive(defmt::Format)]
enum ButtonState {
    Pressed,
    Released,
}

#[embassy_executor::task]
async fn button_task(mut button: ExtiInput<'static>, tx: Sender<'static, ThreadModeRawMutex, ButtonState, 3>) {
    info!("Press the USER button...");
    loop {
        button.wait_for_falling_edge().await;
        tx.send(ButtonState::Pressed).await;
        info!("Pressed!");
        button.wait_for_rising_edge().await;
        tx.send(ButtonState::Released).await;
        info!("Released!");
    }
}
